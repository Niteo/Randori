<!DOCTYPE html>
<style>
  #state {
      padding-top: 1em;
  }
</style>
<body>
<h1>Poll</h1>
<div id="root"></div>
<button onclick="prev()">prev</button>
<button onclick="next()">next</button>
<button onclick="submit()">submit</button>
<blockquote id="state"></blockquote>
<script src="https://unpkg.com/mathjs@7.2.0/dist/math.min.js"></script>

<script>


var data = [];

var poll = {"children": [
{"answers": ["B+", "AB+", "O-", "A-", "Other"],
   "probability": ["1/5", "1/5", "1/5", "1/5", "1/5"],
   "qid": 1,
   "question": "Specify..."},
  {"answers": ["B-", "AB-"],
   "probability": ["3/4", "1/4"],
   "qid": 2,
   "question": "Specify further..."}],
 "paths": [[0, "Other", 1], [1, "Other", 2]],
 "roots": [{"answers": ["O+", "A+", "Other"],
   "probability": ["1/3", "1/3", "1/3"],
   "qid": 0,
   "truth": "1/2",
   "question": "Blood type?"}, 
   {"answers": ["A", "B", "C"],
   "probability": ["1/3", "1/3", "1/3"],
   "qid": 4,
   "truth": "3/4",
   "question": "Q2?"},
   {"answers": ["1", "2"],
   "probability": ["1/2", "1/2"],
   "qid": 3,   
   "truth": "1/3",
   "question": "1 or 2?"}],
 "order": [0, 4, 3]
};

var answers = {};

var idx = 0; 

// Create lookup dict: qid->question
var lookup = {};
var paths = poll["paths"];
var questions = poll["roots"].concat(poll["children"]);
var sorted = [];
var root_indices = [];
var subtrees = [];

var compound_ans_to_prob = {}; 
var matrices = [];
var epsilon_per_subtree = {};

var valid_answers = {};
var ans_to_compound = {};

// Traverse and decorate JSON
function recurse(qid, order) {
  paths.forEach(function(d, i){
  
    let source = d[0];
    let alt = d[1];
    let target = d[2];

    let prefix = alt;
    let parent = lookup[source];
    let parent_index = parent["answers"].indexOf(alt);
    let compound_prob = math.Fraction(parent["probability"][parent_index]);

    parent["to_remove"] = alt;

    if(source==qid){
        let add = lookup[target];
        let parent_prefix = parent["answer_prefix"];
        order.push(add)

        // Continue building string if there is already one
        if(parent_prefix){
            prefix = parent_prefix+alt;
          }

        // Decorate
        add["answer_prefix"] = prefix;
        add["compound_answers"] = add["answers"].map(function (ans) {
                return prefix+ans;
        });

        // Continue with probability from parent answer
        if(parent["compound_probability"]){
          compound_prob = parent["compound_probability"][parent_prefix+alt];
        } 

        // Decorate
        add["compound_probability"] = {};
        add["answers"].forEach(function (answer, index) {
            add["compound_probability"][prefix+answer] = compound_prob.mul(math.Fraction(add["probability"][index]));  
        });

        recurse(target, order);
    } else{
        return order;
    }});
}

function render() {
   
    var q = data[idx];
    var root = document.getElementById("root");
    root.innerHTML = "";
    root.appendChild(createQuestionWithAlternatives(q.text, q.alternatives));

    var state = document.getElementById("state");
    state.innerHTML = JSON.stringify(answers);
}

function createQuestionWithAlternatives(text, alternatives) {
    var div = document.createElement("div");

    var question = document.createElement("p");
    question.innerHTML = text;
    div.appendChild(question);

    var form = document.createElement("form");
    alternatives.forEach(function(alternative) {
	  var input = document.createElement("input");
	  input.type = "radio";
	  input.name = "alternative";
	  input.checked = data[idx].answer === alternative;

	  var text = document.createTextNode(alternative);
	  form.appendChild(input);
	  form.appendChild(text);

	  input.onclick = function() {
	      data[idx]["answer"] = alternative;
        answers[data[idx]["qid"]] = alternative;
	      render();
	  };
      });
      div.appendChild(form);

      return div;
}

function next() {
  if ((idx + 1) >= data.length){
    return;
  }

  idx++;

  var q = data[idx];
  var maybe_condition = q["condition"];
  if(maybe_condition){
    parent = maybe_condition["parent"];
    alt = maybe_condition["answer"];

    if(answers[parent] != alt){
      q["show"] = "false";
      next();
      return;
    } else {

    }

  }

  render();

}

function prev() {
  if ((idx - 1) < 0) {
    return;
  }

  idx--;

  var q = data[idx];
  var maybe_condition = q["condition"];
  if(maybe_condition){
    parent = maybe_condition["parent"];
    alt = maybe_condition["answer"];

    if(answers[parent] != alt){
      prev();
    }

  }

  render();
}

function init() {
  questions.forEach(function(q) {
     q["tuples"] = q["answers"].map(function(a,i) {
      return {"answer": a,
              "probability": q["probability"][i]
          }
     })
  })

  questions.forEach(function(question, i){
      lookup[question["qid"]] = question;
  });


  poll["order"].forEach(function (d, i){
    sorted.push(lookup[d]);
    recurse(d, sorted);
  });

  sorted.forEach(function (question, index){
      data.push({
        "text":question["question"], 
        "alternatives":question["answers"],
        "qid": question["qid"]});
  });

  paths.forEach(function (d) {
      let source = d[0];
      let alt = d[1];
      let target = d[2];

      data.forEach(function (record){
          if(record["qid"]==target){
            record["condition"] = {"parent":source, "answer":alt};

            lookup[target]["condition"] = {"parent":source, "answer":alt};
          }
      });
  });

  sorted.forEach(function (question) {
    if(poll["order"].includes(question["qid"])){
        root_indices.push(sorted.indexOf(question));
    }
  })

  root_indices.forEach(function (elem, i) {
      subtrees.push(sorted.slice(elem, root_indices[i+1]));
  })

    // Compound probability for roots
  poll["roots"].forEach(function (root) {
    root["compound_probability"] = {};
    root["answers"].forEach(function (ans, index) {
      root["compound_probability"][ans] = math.Fraction(root["probability"][index]); 
    })
  });

}



function pollToMatrix(){
  subtrees.forEach(function (subtree, index) {
  let matrix = {};
  let root_index;
  let potential_epsilon = undefined;


    subtree.forEach(function (question) {

      let temp_answers = question["answers"].slice();
      
      // Remove alternatives that aren't leaves
      if(question["to_remove"]){
        let remove_me = question["answers"].indexOf(question["to_remove"]);
        temp_answers.splice(remove_me, 1);
      } 

      // If root
      if(poll["order"].includes(question["qid"])){
        root_index = question["qid"];
        valid_answers[question["qid"]] = temp_answers;
      } else {
        let to_use = [];

        ans_to_compound[question["qid"]] = {};
        temp_answers.forEach(function (ans) {
          let name = question["answer_prefix"]+ans;
          to_use.push(name);

          ans_to_compound[question["qid"]][ans] = name;
        });

        valid_answers[question["qid"]] = to_use;
      }

      });

      // For each input, create a transition to each output
      Object.keys(valid_answers).forEach(function (qid){
        valid_answers[qid].forEach(function (self){

          // Find min/max per row
          let max = undefined;
          let min = undefined;

          matrix[self] = {};

            Object.keys(valid_answers).forEach(function (compare_qid) {
              valid_answers[compare_qid].forEach(function (compare_alt){
                let target_question = lookup[compare_qid];

                let truth = math.Fraction(lookup[root_index]["truth"]);
                // Probability of RANDOM answer
                let random = math.Fraction(1).sub(truth);
                let prob = target_question["compound_probability"][compare_alt].mul(random);

                // Higher probability of not changing answer (self->self)
                if(self == compare_alt){
                  prob = prob.add(truth);                  

                }

                // Initialize first loop
                if(max==undefined && min==undefined){
                  max = prob;
                  min = prob;
                } else if(prob > max){
                  max = prob;
                } else if(prob < min){
                  min = prob;
                }

                matrix[self][compare_alt] = prob; 
              });
            });

            let check = Math.max(max.div(min), min.div(max));
            if(potential_epsilon==undefined || potential_epsilon<check){
              potential_epsilon = check;
            }
        });
      });

  console.log("MATRIX", matrix);
  matrices.push(matrix);

  epsilon_per_subtree[subtree[0]["qid"]] = potential_epsilon;

});
  

}

// Rejection sampling using cryptographic random
function getRandomInt(min, max){
  let a = new Uint8Array(1); //Hold one random value
  let rand_range = 256; //Range of crypto random
  let desired_range = max-min+1; //Inclusive range

  window.crypto.getRandomValues(a); //Inplace

  // If a is within an incomplete interval, reject sample
  if(a[0] >= Math.floor(rand_range/desired_range)*desired_range){
      return getRandomInt(min, max);
  }

  return min + (a[0]%desired_range);
}


function submit() {
  console.log("RANDOMIZE!");
  pollToMatrix();

  subtrees.forEach(function (subtree) {
    let real = undefined;
    let matrix = matrices[subtree];

    subtree.forEach(function (question){
      qid = question["qid"];
      let candidate = answers[qid];

      if(ans_to_compound[qid]){
        candidate = ans_to_compound[qid][candidate];
      }

      if(valid_answers[qid].indexOf(candidate) != -1) {
        real = candidate;
      }

    });

    console.log("Using ", real);

  });

}



init();
render();

</script>
</body>
</html>
