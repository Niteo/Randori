<!DOCTYPE html>
<style>
  #state {
      padding-top: 1em;
  }
</style>
<body>
<h1>Poll</h1>
<div id="root"></div>
<button onclick="prev()">prev</button>
<button onclick="next()">next</button>
<button onclick="submit()">submit</button>
<blockquote id="state"></blockquote>
<script src="https://unpkg.com/mathjs@7.2.0/dist/math.min.js"></script>

<script>


var data = [];

var poll = {"children": [
{"answers": ["B+", "AB+", "O-", "A-", "Other"],
   "probability": ["1/5", "1/5", "1/5", "1/5", "1/5"],
   "qid": 1,
   "question": "Specify..."},
  {"answers": ["B-", "AB-"],
   "probability": ["3/4", "1/4"],
   "qid": 2,
   "question": "Specify further..."}],
 "paths": [[0, "Other", 1], [1, "Other", 2]],
 "roots": [{"answers": ["O+", "A+", "Other"],
   "probability": ["1/3", "1/3", "1/3"],
   "qid": 0,
   "truth": "1/2",
   "question": "Blood type?"}, 
   {"answers": ["A", "B", "C"],
   "probability": ["1/3", "1/3", "1/3"],
   "qid": 4,
   "truth": "3/4",
   "question": "Q2?"},
   {"answers": ["1", "2"],
   "probability": ["1/2", "1/2"],
   "qid": 3,   
   "truth": "1/3",
   "question": "1 or 2?"}],
 "order": [0, 4, 3]
};

var answers = {};
var shadow_answers = {};

var idx = 0; 

// Create lookup dict: qid->question
var lookup = {};
var qid_to_root_index = {};
var paths = poll["paths"];
var questions = poll["roots"].concat(poll["children"]);
var sorted = [];
var root_indices = [];
var subtrees = [];

var compound_ans_to_prob = {}; 
var matrices = {};
var epsilon_per_subtree = {};

var valid_answers_per_subtree = {};
var ans_to_compound = {};
var valid_answers = {};

var responses = undefined;

// Traverse and decorate JSON
function recurse(qid, order) {
  paths.forEach(function(d, i){
  
    let source = d[0];
    let alt = d[1];
    let target = d[2];

    let prefix = alt;
    let parent = lookup[source];
    let parent_index = parent["answers"].indexOf(alt);
    let compound_prob = math.Fraction(parent["probability"][parent_index]);

    parent["to_remove"] = alt;

    if(source==qid){
        let add = lookup[target];
        let parent_prefix = parent["answer_prefix"];
        order.push(add)

        // Continue building string if there is already one
        if(parent_prefix){
            prefix = parent_prefix+alt;
          }

        // Decorate
        add["answer_prefix"] = prefix;
        add["compound_answers"] = add["answers"].map(function (ans) {
                return prefix+ans;
        });

        // Continue with probability from parent answer
        if(parent["compound_probability"]){
          compound_prob = parent["compound_probability"][parent_prefix+alt];
        } 

        // Decorate
        add["compound_probability"] = {};
        add["answers"].forEach(function (answer, index) {
            add["compound_probability"][prefix+answer] = compound_prob.mul(math.Fraction(add["probability"][index]));  
        });

        recurse(target, order);
    } else{
        return order;
    }});
}

function render() {
   
    var q = data[idx];
    var root = document.getElementById("root");
    root.innerHTML = "";
    root.appendChild(createQuestionWithAlternatives(q.text, q.alternatives));

    var state = document.getElementById("state");
    state.innerHTML = JSON.stringify(answers);
}

function createQuestionWithAlternatives(text, alternatives) {
    var div = document.createElement("div");

    var question = document.createElement("p");
    question.innerHTML = text;
    div.appendChild(question);

    var form = document.createElement("form");
    alternatives.forEach(function(alternative) {
	  var input = document.createElement("input");
	  input.type = "radio";
	  input.name = "alternative";
	  input.checked = data[idx].answer === alternative;

	  var text = document.createTextNode(alternative);
	  form.appendChild(input);
	  form.appendChild(text);

	  input.onclick = function() {
        let qid = data[idx]["qid"];
	      data[idx]["answer"] = alternative;
        answers[qid] = alternative;

        let parent_index = qid_to_root_index[qid];
        let to_use = alternative;
        if(qid != parent_index){
          alternative = ans_to_compound[qid][alternative];
          console.log("Finding compound", ans_to_compound, alternative)
        }

        shadow_answers[parent_index] = alternative;
	      render();
	  };
      });
      div.appendChild(form);

      return div;
}

function next() {
  if ((idx + 1) >= data.length){
    return;
  }

  idx++;

  var q = data[idx];
  var maybe_condition = q["condition"];
  if(maybe_condition){
    parent = maybe_condition["parent"];
    alt = maybe_condition["answer"];

    if(answers[parent] != alt){
      q["show"] = "false";
      next();
      return;
    } else {

    }

  }

  render();

}

function prev() {
  if ((idx - 1) < 0) {
    return;
  }

  idx--;

  var q = data[idx];
  var maybe_condition = q["condition"];
  if(maybe_condition){
    parent = maybe_condition["parent"];
    alt = maybe_condition["answer"];

    if(answers[parent] != alt){
      prev();
    }

  }

  render();
}

function init() {

  // Pair answer with probability
  questions.forEach(function(q) {
     q["tuples"] = q["answers"].map(function(a,i) {
      return {"answer": a,
              "probability": q["probability"][i]
          }
     })
  })

  // Map qid->question
  questions.forEach(function(question, i){
      lookup[question["qid"]] = question;
  });


  // Find the question order
  poll["order"].forEach(function (d, i){
    sorted.push(lookup[d]);
    recurse(d, sorted);
  });

  // Prepare data structure to show user
  sorted.forEach(function (question, index){
      data.push({
        "text":question["question"], 
        "alternatives":question["answers"],
        "qid": question["qid"]});
  });

  // Decorate user structure with conditions for proper next/previous functionality
  paths.forEach(function (d) {
      let source = d[0];
      let alt = d[1];
      let target = d[2];

      data.forEach(function (record){
          if(record["qid"]==target){
            record["condition"] = {"parent":source, "answer":alt};

            lookup[target]["condition"] = {"parent":source, "answer":alt};
          }
      });
  });

  // Store all root indices for easy lookup
  sorted.forEach(function (question) {
    if(poll["order"].includes(question["qid"])){
        root_indices.push(sorted.indexOf(question));
    }
  })

  // A subtree is an ORDERED set of root+follow-ups
  root_indices.forEach(function (elem, i) {
      subtrees.push(sorted.slice(elem, root_indices[i+1]));
  })

    // Compound probability for roots
  poll["roots"].forEach(function (root) {
    root["compound_probability"] = {};
    root["answers"].forEach(function (ans, index) {
      root["compound_probability"][ans] = math.Fraction(root["probability"][index]); 
    })
  });


  // Add mapping qid->root_qid
  subtrees.forEach(function (subtree, index) {
      let root_index = subtree[0]["qid"];

      subtree.forEach(function (question){
        let qid = question["qid"];
        qid_to_root_index[qid] = root_index;
      });
  });

  // Populate valid_answers and ans_to_compound
  subtrees.forEach(function (subtree, index) {
    subtree.forEach(function (question) {

    let temp_answers = question["answers"].slice();
    
    // Remove alternatives that aren't leaves
    if(question["to_remove"]){
      let remove_me = question["answers"].indexOf(question["to_remove"]);
      temp_answers.splice(remove_me, 1);
    } 

    // If root
    if(poll["order"].includes(question["qid"])){
      root_index = question["qid"];
      valid_answers[root_index] = temp_answers;
      valid_answers_per_subtree[root_index]=temp_answers
    } else {
      let to_use = [];

      ans_to_compound[question["qid"]] = {};
      temp_answers.forEach(function (ans) {
        let name = question["answer_prefix"]+ans;
        to_use.push(name);

        ans_to_compound[question["qid"]][ans] = name;
      });

      valid_answers[question["qid"]] = to_use;
      valid_answers_per_subtree[root_index]+= to_use;
    }

    });

  });


}



function pollToMatrix(){
  let output = {};

  subtrees.forEach(function (subtree, index) {

    let matrix = {};
    let root_index;
    let potential_epsilon = undefined;


      // For each input, create a transition to each output
      Object.keys(valid_answers).forEach(function (qid){
        valid_answers[qid].forEach(function (self){

          // Find min/max per row
          let max = undefined;
          let min = undefined;

          matrix[self] = {};

            Object.keys(valid_answers).forEach(function (compare_qid) {
              valid_answers[compare_qid].forEach(function (compare_alt){
                let target_question = lookup[compare_qid];

                let truth = math.Fraction(lookup[root_index]["truth"]);
                // Probability of RANDOM answer
                let random = math.Fraction(1).sub(truth);
                let prob = target_question["compound_probability"][compare_alt].mul(random);

                // Higher probability of not changing answer (self->self)
                if(self == compare_alt){
                  prob = prob.add(truth);                  

                }

                // Initialize first loop
                if(max==undefined && min==undefined){
                  max = prob;
                  min = prob;
                } else if(prob > max){
                  max = prob;
                } else if(prob < min){
                  min = prob;
                }

                matrix[self][compare_alt] = prob; 
              });
            });

            let check = Math.max(max.div(min), min.div(max));
            if(potential_epsilon==undefined || potential_epsilon<check){
              potential_epsilon = check;
            }
        });
      });

  output[root_index]=matrix;

  epsilon_per_subtree[subtree[0]["qid"]] = potential_epsilon;


});
  return output;
}

function randomMatrix(){
  let output = {};

  subtrees.forEach(function (subtree, index) {

    let matrix = {};
    let root_index;
    let potential_epsilon = undefined;
    let valid_answers = {};

    subtree.forEach(function (question) {

      let temp_answers = question["answers"].slice();
      
      // Remove alternatives that aren't leaves
      if(question["to_remove"]){
        let remove_me = question["answers"].indexOf(question["to_remove"]);
        temp_answers.splice(remove_me, 1);
      } 

      // If root
      if(poll["order"].includes(question["qid"])){
        root_index = question["qid"];
        valid_answers[root_index] = temp_answers;
        valid_answers_per_subtree[root_index]=temp_answers
      } else {
        let to_use = [];

        ans_to_compound[question["qid"]] = {};
        temp_answers.forEach(function (ans) {
          let name = question["answer_prefix"]+ans;
          to_use.push(name);

          ans_to_compound[question["qid"]][ans] = name;
        });

        valid_answers[question["qid"]] = to_use;
        valid_answers_per_subtree[root_index]+= to_use;
      }

      });

      // For any input, create a transition to each output
      matrix = {};

      Object.keys(valid_answers).forEach(function (compare_qid) {
        valid_answers[compare_qid].forEach(function (compare_alt){
          let target_question = lookup[compare_qid];

          // Probability of RANDOM answer
          let random = math.Fraction(1);
          let prob = target_question["compound_probability"][compare_alt].mul(random);

          matrix[compare_alt] = prob; 
        });
      });


  output[root_index]=matrix;
  });
return output;
}

// Rejection sampling using cryptographic random
function getRandomInt(min, max){
  let a = new Uint16Array(1); //Hold one random value
  let rand_range = 65536; //Range of crypto random
  let desired_range = max-min+1; //Inclusive range

  window.crypto.getRandomValues(a); //Inplace

  // If a is within an incomplete interval, reject sample
  if(a[0] >= Math.floor(rand_range/desired_range)*desired_range){
      return getRandomInt(min, max);
  }

  return min + (a[0]%desired_range);
}

function fullRandom(matrices) {
  let output = {};
  
  // Prepare a response for each question tree
  subtrees.forEach(function (subtree, index) {
    let root_index = subtree[0]["qid"];
    let transitions = matrices[root_index];
    let common_denominator = 1;

    console.log("COIN FLIP");
    console.log("Transition matrix is ", transitions);

    // Find gcd to calculate relative weight for probability distribution
    for(key in transitions) {
      let d = transitions[key].d;
      if(d > common_denominator){
        common_denominator = d;
      }
    }

    // Populate with relative weights
    let answer_relative_weight = {};
    for(key in transitions) {
      let d = transitions[key].d;
      let n = transitions[key].n;
      let multiplier = common_denominator/d;
      let weight = n*multiplier;
      answer_relative_weight[key] = weight;
      
    }

    // Ranges [include, exclude]
    let count = 1;
    let ranges = {};
    for(key in answer_relative_weight){
      let start = count;
      let stop = answer_relative_weight[key]+count-1;
      count +=answer_relative_weight[key];

      for(let i=start; i<=stop; i++){
          ranges[i] = key;
      }
    }
    //Use cryptographic random [1-gcd] and pick the winner
    let random = getRandomInt(1,common_denominator);
    output[root_index] = ranges[random];

    console.log("Output ", output[root_index]);


  });

  console.log(output)
  return output;

}



function randomizedResponse(matrices, given_answers) {
  let output = {};
  
  // Prepare a response for each question tree
  subtrees.forEach(function (subtree, index) {
    let real = undefined;
    let root_index = subtree[0]["qid"];
    let matrix = matrices[root_index];

    // Get rid of invalid responses, i.e non-leaves
    subtree.forEach(function (question){
      let qid = question["qid"];
      let candidate = given_answers[qid];

      if(ans_to_compound[qid] && qid!=root_index){
        candidate = ans_to_compound[qid][candidate];
      }

      if(valid_answers_per_subtree[root_index].indexOf(candidate) != -1) {
        real = candidate;
      }

    });

    if(real != undefined){
      let transitions = matrix[real];
      let common_denominator = 1;
      console.log("Input ", real);

      console.log("COIN FLIP");
      console.log("Transition matrix is ", transitions);

      // Find gcd to calculate relative weight for probability distribution
      for(key in transitions) {
        let d = transitions[key].d;
        if(d > common_denominator){
          common_denominator = d;
        }
      }


      // Populate with relative weights
      let answer_relative_weight = {};
      for(key in transitions) {
        let d = transitions[key].d;
        let n = transitions[key].n;
        let multiplier = common_denominator/d;
        let weight = n*multiplier;
        answer_relative_weight[key] = weight;
        
      }

      // Ranges [include, exclude]
      let count = 1;
      let ranges = {};
      for(key in answer_relative_weight){
        let start = count;
        let stop = answer_relative_weight[key]+count-1;
        count +=answer_relative_weight[key];

        for(let i=start; i<=stop; i++){
            ranges[i] = key;
        }
      }
      //Use cryptographic random [1-gcd] and pick the winner
      let random = getRandomInt(1,common_denominator);
      output[root_index] = ranges[random];

      console.log("Output ", output[root_index]);

    }

  });

  console.log(output)
  return output;

}

function submit(){


  console.log("SENDING RESPONSES");

}



//GET
init();
var random_matrices = randomMatrix();
var random_answers = fullRandom(random_matrices);
var matrices = undefined;
render();


// TIMEOUT



//matrices = pollToMatrix();
matrices_to_use = undefined;
answers_to_use = {};

// WARNING!
// Be sure to make loop constant time, no loops on actual data
for(answer_index in random_answers){
    if(answers[answer_index]){
      console.log("Answer exist")
      answers_to_use[answer_index] = answers[answer_index];
    } else {
      answers_to_use[answer_index] = random_answers[answer_index];
    }
}

//POST

//responses = randomizedResponse(matrices_to_use, answers);

</script>
</body>
</html>
