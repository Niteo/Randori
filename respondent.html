<!DOCTYPE html>
<style>
  #state {
      padding-top: 1em;
  }
</style>
<body>
<h1>Poll</h1>
<div id="root"></div>
<button onclick="prev()">prev</button>
<button onclick="next()">next</button>
<button onclick="submit()">submit</button>
<blockquote id="state"></blockquote>
<script>


var data = [];

var poll = {"children": [
{"answers": ["B+", "AB+", "O-", "A-", "Other"],
   "probability": ["1/5", "1/5", "1/5", "1/5", "1/5"],
   "qid": 1,
   "question": "Specify..."},
  {"answers": ["B-", "AB-"],
   "probability": ["3/4", "1/4"],
   "qid": 2,
   "question": "Specify further..."}],
 "paths": [[0, "Other", 1], [1, "Other", 2]],
 "roots": [{"answers": ["O+", "A+", "Other"],
   "probability": ["1/3", "1/3", "1/3"],
   "qid": 0,
   "question": "Blood type?"}, 
   {"answers": ["A", "B", "C"],
   "probability": ["1/3", "1/3", "1/3"],
   "qid": 4,
   "question": "Q2?"},
   {"answers": ["1", "2"],
   "probability": ["1/2", "1/2"],
   "qid": 3,
   "question": "1 or 2?"}],
 "truth": ["1/2"],
 "order": [0, 4, 3]
};

var answers = {};

var idx = 0; 

// Create lookup dict: qid->question
var lookup = {};
var paths = poll["paths"];
var questions = poll["roots"].concat(poll["children"]);
var sorted = [];
var root_indices = [];
var subtrees = [];



function recurse(qid, order) {
  paths.forEach(function(d, i){
  
    let source = d[0];
    let alt = d[1];
    let target = d[2];

    let prefix = alt;
    let parent = lookup[source];
    let parent_index = parent["answers"].indexOf(alt);
    let compound_prob = eval(parent["probability"][parent_index]);

    parent["to_remove"] = alt;

    if(source==qid){
        let add = lookup[target];
        order.push(add)

        add["compund_probability"] = [];
        add["answers"].forEach(function (answer, index) {
          
          if(parent["answer_prefix"]){
            prefix = parent["answer_prefix"]+alt;
          }

          if(parent["compund_probability"]){
            compound_prob = parent["compund_probability"][parent_index];
          }

            add["answer_prefix"] = prefix;
            add["compund_probability"].push(compound_prob*eval(add["probability"][index]));
            console.log("prefix \n")
            console.log(add["answer_prefix"], add["compund_probability"]);
        });

        recurse(target, order);
    } else{
        return order;
    }});
}

function render() {
   
    var q = data[idx];
    var root = document.getElementById("root");
    root.innerHTML = "";
    root.appendChild(createQuestionWithAlternatives(q.text, q.alternatives));

    var state = document.getElementById("state");
    state.innerHTML = JSON.stringify(answers);
}

function createQuestionWithAlternatives(text, alternatives) {
    var div = document.createElement("div");

    var question = document.createElement("p");
    question.innerHTML = text;
    div.appendChild(question);

    var form = document.createElement("form");
    alternatives.forEach(function(alternative) {
	  var input = document.createElement("input");
	  input.type = "radio";
	  input.name = "alternative";
	  input.checked = data[idx].answer === alternative;

	  var text = document.createTextNode(alternative);
	  form.appendChild(input);
	  form.appendChild(text);

	  input.onclick = function() {
	      data[idx]["answer"] = alternative;
        answers[data[idx]["qid"]] = alternative;
	      render();
	  };
      });
      div.appendChild(form);

      return div;
}

function next() {
  if ((idx + 1) >= data.length){
    return;
  }

  idx++;

  var q = data[idx];
  var maybe_condition = q["condition"];
  if(maybe_condition){
    parent = maybe_condition["parent"];
    alt = maybe_condition["answer"];

    if(answers[parent] != alt){
      q["show"] = "false";
      next();
      return;
    } else {

    }

  }

  render();

}

function prev() {
  if ((idx - 1) < 0) {
    return;
  }

  idx--;

  var q = data[idx];
  var maybe_condition = q["condition"];
  if(maybe_condition){
    parent = maybe_condition["parent"];
    alt = maybe_condition["answer"];

    if(answers[parent] != alt){
      prev();
    }

  }

  render();
}

function init() {
  questions.forEach(function(q) {
     q["tuples"] = q["answers"].map(function(a,i) {
      return {"answer": a,
              "probability": q["probability"][i]
          }
     })
  })

  questions.forEach(function(question, i){
      lookup[question["qid"]] = question;
  });


  poll["order"].forEach(function (d, i){
    sorted.push(lookup[d]);
    recurse(d, sorted);
  });

  sorted.forEach(function (question, index){
      data.push({
        "text":question["question"], 
        "alternatives":question["answers"],
        "qid": question["qid"]});
  });

  paths.forEach(function (d) {
      let source = d[0];
      let alt = d[1];
      let target = d[2];

      data.forEach(function (record){
          if(record["qid"]==target){
            record["condition"] = {"parent":source, "answer":alt};

            lookup[target]["condition"] = {"parent":source, "answer":alt};
          }
      });
  });


  sorted.forEach(function (question) {
    if(poll["order"].includes(question["qid"])){
        root_indices.push(sorted.indexOf(question));
    }
})


root_indices.forEach(function (elem, i) {
    subtrees.push(sorted.slice(elem, root_indices[i+1]));
})

}

function submit() {
  console.log("RANDOMIZE!");
  pollToMatrix();

}

function pollToMatrix(){

  

}



init();

var matrices = [];

subtrees.forEach(function (subtree) {
  let lowest = undefined;
  let highest = undefined;
  let matrix = {};

    let valid_answers = []
    subtree.forEach(function (question) {

      let temp_answers = question["answers"].slice()
      
      if(question["to_remove"]){
        let remove_me = question["answers"].indexOf(question["to_remove"]);
        temp_answers.splice(remove_me, 1);
      } 

      // If root
      if(poll["order"].includes(question["qid"])){

        //console.log(question["probability"]);
        valid_answers = temp_answers;

      } else {
        //console.log(question["compund_probability"]);
        let to_use = [];

        temp_answers.forEach(function (ans) {
          to_use.push(question["answer_prefix"]+ans);
        });

        valid_answers = valid_answers.concat(to_use);
      }

      valid_answers.forEach(function (self) {
        matrix[self] = {};

          valid_answers.forEach(function (compare) {
            let prob;
            if(self == compare){
              //console.log("higher prob");
            }

            matrix[self][compare] = prob;
      });
      });

    });

  console.log("FINAL LIST ", valid_answers);

    matrices.push(matrix);
});

render();

</script>
</body>
</html>
